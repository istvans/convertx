#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
sys.path.append("/lib/convert-x")

import cxcfg as cfg
from cxmsg import Msg, Type
import cxproc as cxp
from cxutils import eprint
import cxwindow as cx
import os
from queue import Queue
import re
import subprocess
import threading as th
import time

###############################################################################

class InfoGetter:
    ### Public Methods ###
    def __init__(self, window_queue, finished_cb=None):
        self.__window_q = window_queue
        self.__finished_cb = finished_cb
        self.__video_parser_proc = None
        self.__gather_thread = None
        self.__finished = False
        self.__cancelled = False
        self.__exiting = False
        self.__input_file = None
        self.num_of_frames = None
        self.one_percent = None

    def __bool__(self):
        return self.num_of_frames is not None and self.one_percent is not None

    def start(self, input_file):
        if input_file is None:
            raise RuntimeError("INTERNAL ERROR: input file should have "
                    "been already received!")
        
        if self.__finished and self.__input_file is not None \
            and self.__input_file == input_file:
            self.__finish()
            return
        
        self.__input_file = input_file
        self.__finished = False
        self.__cancelled = False
        self.__window_q.put(Msg(Type.PREP))
           
        if self.__video_parser_proc is None:
            self.__video_parser_proc = cxp.create_video_parser(input_file)
        
        if self.__gather_thread is None:
            self.__gather_thread = th.Thread(target=self.__gather)
            self.__gather_thread.start()
    
    def stop(self, exiting=False):
        self.__exiting = exiting
        self.__cancelled = True
        cxp.terminate(process=self.__video_parser_proc)

    def run(self, frame):
        if not self:
            return True
        return frame < self.num_of_frames
    
    ### Private Methods ###
        
    def __gather(self):
        last_match = None
        for line in iter(self.__video_parser_proc.stdout.readline, ""):
            l = line.rstrip()
            match = re.search("^\s*frame=\s*(\d+)", l)
            if match:
                last_match = match

        if self.__exiting:
            return
       
        # to allow restart
        self.__video_parser_proc = None
        self.__gather_thread = None
        
        if self.__cancelled:
            return

        if last_match:
            self.num_of_frames = int(last_match.group(1))
            self.one_percent = self.num_of_frames / 100

        if self.num_of_frames is None:
            self.__window_q.put(Msg(Type.WARN_UNKNOWN_REMAINING_TIME))

        self.__finish()

    def __finish(self):
        self.__finished = True
        if self.__finished_cb is not None:
            self.__finished_cb()

###############################################################################

class Application:
    ### Public Methods ###
    def __init__(self):
        self.__cfg = cfg.Manager()
        self.__window_q = Queue()
        self.__app_q = Queue()
        self.__window = cx.Window(window_queue=self.__window_q
                , app_queue=self.__app_q, cfg=self.__cfg)
        self.__input_info = InfoGetter(window_queue=self.__window_q)
        self.__progress_thread = None
        self.__converter_proc = None 
        
        self.__run = True
        while self.__run:
            self.__step()
    
    ### Private Methods ###

    def __step(self):
        """ Process one message from the queue """
        msg = self.__app_q.get(block=True)
        if msg.type == Type.START:
            self.__start_conversion(msg.data)
        elif msg.type == Type.STOP:
            self.__stop(stay_alive=True)
        elif msg.type == Type.CLOSE:
            self.__stop(stay_alive=False)
        elif msg.type == Type.DELETE:
            self.__remove_file(msg.data[0])
        elif msg.type == Type.SET_CFG:
            self.__cfg.set(msg.data[0], msg.data[1])
        elif msg.type == Type.INPUT_FILE:
            self.__input_file = msg.data[0]
            self.__input_info.start(self.__input_file)
        elif msg.type == Type.OUTPUT_FILE:
            self.__output_file = msg.data[0]

    def __stop(self, stay_alive):
        self.__input_info.stop(exiting=not stay_alive)

        cxp.terminate(process=self.__converter_proc)

        if stay_alive:
            self.__window_q.put(Msg(Type.STOP_ACK))
        else:
            self.__window_q.put(Msg(Type.CLOSE_ACK))
            self.__run = False

    def __start_conversion(self, optional_streams):
        if self.__input_file is None:
            raise RuntimeError("INTERNAL ERROR: input file should have "
                    "been already received!")
        if self.__output_file is None:
            raise RuntimeError("INTERNAL ERROR: output file should have "
                    "been already received!")
        self.__window_q.put(Msg(Type.CONV))
       
        if self.__converter_proc is None:
            self.__converter_proc = cxp.create_converter(self.__input_file
                , optional_streams, self.__output_file)
    
        if self.__progress_thread is None:
            self.__progress_thread = th.Thread(target=self.__progress)
            self.__progress_thread.start()

    def __progress(self):
        """ Monitor the progress of the conversion and report it to the
        GUI thread
        """
        t = th.currentThread()
        start = time.time()
        percent = 0.0
        progress = 0.0
        frame = 0
        for line in iter(self.__converter_proc.stdout.readline, ""):
            if self.__input_info:
                match = re.search("frame=\s*(\d+)", line)
                if match:
                    now = time.time()
                    frame = int(match.group(1))
                    if frame >= percent:
                        percent = (frame / self.__input_info.one_percent)
                        incr = percent - progress
                        self.__window_q.put(Msg(Type.STEP, incr))
                        progress += incr
                        percent = frame + self.__input_info.one_percent

                elapsed = time.time() - start
                self.__window_q.put(Msg(Type.ELAPSED
                    , self.__sec2time(elapsed)))
              
                if frame:
                    needed_per_frame = elapsed / frame
                    left = self.__input_info.num_of_frames - frame
                    estimate = left * needed_per_frame
                    self.__window_q.put(Msg(Type.LEFT
                        , self.__sec2time(estimate)))

        if frame == self.__input_info.num_of_frames:
            self.__window_q.put(Msg(Type.FINISHED))
        
        # to allow restart
        self.__converter_proc = None
        self.__progress_thread = None

    def __remove_file(self, file_path):
        try:
            os.remove(file_path)
        except FileNotFoundError as e:
            eprint(e)

    def __sec2time(self, seconds):
        m, s = divmod(seconds, 60)
        h, m = divmod(m, 60)
        return "%d:%02d:%02d" % (h, m, s)

###############################################################################
###############################################################################

if __name__ == "__main__":
    Application()
