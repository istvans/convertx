#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
sys.path.append("/lib/convert-x")

import cxcfg as cfg
from cxmsg import Msg, Type
import cxproc as cxp
from cxutils import eprint
import cxwindow as cx
import os
from queue import Queue

###############################################################################

class Application:
    ### Public Methods ###
    def __init__(self):
        self.__cfg = cfg.Manager()
        self.__window_q = Queue()
        self.__app_q = Queue()
        self.__window = cx.Window(window_queue=self.__window_q
                , app_queue=self.__app_q, cfg=self.__cfg)
        self.__input_file = None
        self.__num_of_frames = None
        self.__one_percent = None
        self.__video_parser = None
        self.__converter = None 
        
        self.__run = True
        while self.__run:
            self.__step()
    
    ### Private Methods ###

    def __step(self):
        """ Process one message from the queue """
        msg = self.__app_q.get(block=True)
        if msg.type == Type.START:
            self.__start_conversion(msg.data[0])
        elif msg.type == Type.STOP:
            self.__stop(stay_alive=True)
        elif msg.type == Type.CLOSE:
            self.__stop(stay_alive=False)
        elif msg.type == Type.DELETE:
            self.__remove_file(msg.data[0])
        elif msg.type == Type.SET_CFG:
            self.__cfg.set(msg.data[0], msg.data[1])
        elif msg.type == Type.INPUT_FILE:
            self.__parse_video(msg.data[0])
        elif msg.type == Type.OUTPUT_FILE:
            self.__output_file = msg.data[0]
    
    def __parse_video(self, input_file):
        prev_input_file = self.__input_file
        self.__input_file = input_file
        if prev_input_file == self.__input_file and\
                self.__video_parser is not None and self.__video_parser.finished:
            self.__video_parsed()
        else:
            self.__video_parser = cxp.VideoParserCommand(self.__input_file
                    , self.__video_parsed)
            self.__num_of_frames = None
            self.__one_percent = None
            self.__video_parser.start()
    
    def __video_parsed(self):
        if self.__video_parser.permission_error:
            self.__window_q.put(Msg(Type.WARN_PERMISSION_ERROR))
        elif self.__video_parser.num_of_frames is None:
            self.__window_q.put(Msg(Type.WARN_UNKNOWN_REMAINING_TIME))

        if not self.__video_parser.permission_error:
            self.__num_of_frames = self.__video_parser.num_of_frames
            self.__one_percent = self.__video_parser.one_percent
            self.__window_q.put(Msg(Type.OPENED, self.__video_parser.streams))

    def __stop(self, stay_alive):
        if self.__video_parser is not None:
            self.__video_parser.stop()
        if self.__converter is not None:
            self.__converter.stop()
        if stay_alive:
            self.__window_q.put(Msg(Type.STOP_ACK))
        else:
            self.__window_q.put(Msg(Type.CLOSE_ACK))
            self.__run = False

    def __start_conversion(self, streams):
        if self.__input_file is None:
            raise RuntimeError("INTERNAL ERROR: input file should have "
                    "been already received!")
        if self.__output_file is None:
            raise RuntimeError("INTERNAL ERROR: output file should have "
                    "been already received!")

        self.__converter = cxp.ConverterCommand(self.__input_file, streams, self.__output_file
                , self.__num_of_frames, self.__one_percent
                , self.__conversion_step, self.__conversion_elapsed, self.__conversion_left, self.__conversion_finished)
        self.__converter.start()

    def __conversion_step(self, increment):
        self.__window_q.put(Msg(Type.STEP, increment))

    def __conversion_elapsed(self, elapsed_seconds):
        self.__window_q.put(Msg(Type.ELAPSED, elapsed_seconds))
    
    def __conversion_left(self, left_seconds):
        self.__window_q.put(Msg(Type.LEFT, left_seconds))

    def __conversion_finished(self, cancelled, failed, err_msg):
        if not cancelled:
            if failed:
                self.__window_q.put(Msg(Type.FAILED, err_msg))
            else:
                self.__window_q.put(Msg(Type.FINISHED))

    def __remove_file(self, file_path):
        try:
            os.remove(file_path)
        except FileNotFoundError as e:
            eprint(e)

###############################################################################
###############################################################################

if __name__ == "__main__":
    Application()
